<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id='app'>
        <h1>{{ reveseMsgFn() }}</h1>
        <h1>{{ reveseMsgFn() }}</h1>
        <h1>{{ reveseMsgFn() }}</h1>
        <h1>{{ reveseMsgFn() }}</h1>
        <h1>{{ reveseMsgFn() }}</h1>
        <hr>
        <h1>{{ reveseMsg }}</h1>
        <h1>{{ reveseMsg }}</h1>
        <h1>{{ reveseMsg }}</h1>
        <h1>{{ reveseMsg }}</h1>
        <h1>{{ reveseMsg }}</h1>
    </div>

    <script src="./vue.js"></script>

    <script>
        /* 
        效果是反转字符串，但是在模板中写了很复杂的逻辑，难以维护
        模板中泄露大量的逻辑，会导致模板过重，不好维护
        如果一个结果依赖于data中的数据，并且需要经过一定的计算，才能得到结果没推荐使用计算属性

        计算属性：
        1.写在conputed中
        2.计算属性写法上是一个函数，但实质上是一个属性
        3.计算属性，是需要通过计算得到的属性，函数中封装了计算过程，真正属性的值，是函数的返回值

        计算属性的优点：
        1.便于维护，将模板中复杂的逻辑，封装到了计算属性中
        2.计算属性有缓存，计算完成后，会将计算的结果缓存起来
            如果再次获取同一个计算属性，那么久不需要重复计算，直接读缓存即可
        3.依赖的值，如果发生了变化，计算属性会自动重新计算，并再次缓存

        */

        const vm = new Vue({
            el: "#app",
            data: {
                msg: 'hello vue'
            },
            methods: {
                reveseMsgFn() {
                    console.log('函数执行了');
                    return this.msg.split('').revese().join('')
                }
            },
            // 计算属性，计算函数中的this指向当前的vm实例
            computed: {
                reveseMsg() {
                    // 计算逻辑
                    return this.msg.split('').revese().join('')
                }
            }
        })
    </script>
</body>

</html>